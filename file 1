import numpy as np
from scipy.stats import norm

# Parameters
S0 = 35     # Initial stock price
K = 35      # Strike price
T = 1       # Time to maturity in years
sigma = 0.40  # Volatility (40% per annum)
r = 0.01    # Risk-free rate (1% per annum)
q = 0.03    # Dividend yield (3% per annum)
num_simulations = 1000000  # Number of Monte Carlo simulations

# Black-Scholes formula for European call option
def black_scholes_call(S0, K, T, r, sigma, q):
    d1 = (np.log(S0 / K) + (r - q + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    call_price = S0 * np.exp(-q * T) * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)
    return call_price

# Calculating the theoretical price of the European call option
call_price_bs = black_scholes_call(S0, K, T, r, sigma, q)

# Function to simulate end stock prices using Geometric Brownian Motion
def simulate_stock_prices(S0, T, r, sigma, q, num_simulations):
    dt = T  # As we're only interested in the price at maturity
    random_shocks = np.random.normal(0, 1, num_simulations)
    S_T = S0 * np.exp((r - q - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * random_shocks)
    return S_T

# Simulating end stock prices
S_T_simulated = simulate_stock_prices(S0, T, r, sigma, q, num_simulations)

# Calculating payoffs for European put and call options
put_payoffs = np.maximum(K - S_T_simulated, 0)
put_price = np.exp(-r * T) * np.mean(put_payoffs)  # Discounted average payoff
call_payoffs = np.maximum(S_T_simulated - K, 0)
std_deviation = np.std(put_payoffs)

# Standard Error
SE = std_deviation / np.sqrt(num_simulations)

# 95% Confidence Interval
z_score = 1.96  # z-score for 95% confidence
CI_lower = put_price - z_score * SE
CI_upper = put_price + z_score * SE

print("Estimated price of the European put option:", put_price)
print("Standard Error:", SE)
print("95% Confidence Interval: [", CI_lower, ",", CI_upper, "]")

# Applying Control Variate Technique
# Estimating beta (covariance/variance)
beta = np.cov(call_payoffs, put_payoffs)[0, 1] / np.var(call_payoffs)

# Adjusted put payoffs
adjusted_put_payoffs = put_payoffs + beta * (call_price_bs - call_payoffs)

# Calculate the average of the adjusted payoffs and discount it to the present value
put_price_mc_cv = np.mean(adjusted_put_payoffs) * np.exp(-r * T)
# Calculating the standard error of the adjusted put payoffs
std_error = np.std(adjusted_put_payoffs) / np.sqrt(num_simulations)

# 95% Confidence Interval
confidence_level = 0.95
z_score = norm.ppf((1 + confidence_level) / 2)  # z-score for 95% confidence
margin_of_error = z_score * std_error

# Confidence interval
lower_bound = put_price_mc_cv - margin_of_error
upper_bound = put_price_mc_cv + margin_of_error

# Output the standard error and confidence interval
print("...................................................................................................")
print("results after variance reduction method applied:")
print("stantard error :",std_error)
print("95% confidence Interval-->",lower_bound,":",upper_bound)

print(put_price_mc_cv)
